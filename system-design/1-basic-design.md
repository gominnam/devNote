## 사용자 규모에 따른 규모 확장성


### 1. 어떤 Database를 사용할 것인가?

- **SQL Database** (ex. MySQL, PostgreSQL)
  - **수직 확장**이 어렵다.
  - **수평 확장**을 위해 **Sharding**이나 **Replication**을 사용해야 한다.
  - **ACID** 트랜잭션을 지원한다.
  - **JOIN**을 사용할 수 있다.
  - **Schema**를 사용한다.
  - **관계형 데이터**를 다루기에 적합하다.
  - **데이터 무결성**을 보장한다.
  - **일관성**을 보장한다.
</br></br>
  
- **NoSQL Database** (ex. MongoDB, Cassandra)
  - **수평 확장**이 쉽다.
  - **수직 확장**을 위해 **Sharding**이나 **Replication**을 사용할 수 있다.
  - **ACID** 트랜잭션을 지원하지 않는다.
  - **JOIN**을 사용할 수 없다.
  - **Schema-less**이다.
  - **대용량 데이터**를 다루기에 적합하다.
  - **데이터 무결성**을 보장하지 않는다.
  - **일관성**을 보장하지 않는다.
  - **빠른 읽기/쓰기**가 가능하다. (낮은 Latency가 요구 될 때 사용)



### 2. 수직적 규모 확장 VS 수평적 규모 확장

- **수직적 규모 확장 (Vertical Scaling)**
  - **Scale-up**이라고도 한다.
  - **단일 서버**의 성능을 향상시키는 방법이다.
  - **CPU, RAM, SSD** 등을 업그레이드 하는 방법이다.
  - **비용**이 비싸다.
  - **한계**가 있다.
</br></br>
  
- **수평적 규모 확장 (Horizontal Scaling)**
  - **Scale-out**이라고도 한다.
  - **여러 서버**를 추가하는 방법이다.
  - **Sharding**이나 **Replication**을 사용한다.
  - **비용**이 비교적 저렴하다.
  - **무한한 확장성**을 가진다.


### 3. Load Balancer (로드밸런서)

- **로드밸런서**는 **부하 분산 집합**에 속한 웹 서버들에게 **트래픽 부하를 분산**하는 역할을 한다. 
- Client -> (Public IP) Load Balancer -> (Private IP) Web Server  [ Private IP: 보안을 위해 같은 네트워크에 속한 서버 간 통신 ]
- **로드밸런서**는 **Health Check**를 통해 **정상적인 서버**에만 트래픽을 전달한다.



### 4. Database (데이터베이스 다중화)

- 서버 사이에 주(Master)와 보조(Slave) 데이터베이스를 구축하여 **데이터베이스 다중화**를 구현한다.
- 쓰기(Write)는 **Master**에, 읽기(Read)는 **Slave**에 분산하여 **부하 분산**을 구현한다.
- **Master**에 장애가 발생하면 **Slave** 중 하나를 **Master**로 승격시킨다.
  - 장애가 발생한 경우 : 1) 복구 스크립트를 돌려 추가 작업 수행 2) 다중 마스터나 원형 다중화 방식을 도입 (복잡하다)



### 5. Cache (캐시)

- **값 비싼 연산 결과** 또는 **빈번하게 사용되는 데이터**를 **캐시**에 저장하여 **응답 시간을 단축**한다. 
- **Web Server** -> **Cache** -> **Database** (Cache Hit 인 경우 생략) -> **Web Server**
- **Cache** 사용 시 유의점
  - 갱신은 자주 일어나지 않지만 참조는 빈번한 경우 적합하다.
  - **Cache**는 휘발성 메모리 이므로 영속적으로 보관할 데이터를 캐시에 저장하면 안된다.
  - **일관성**을 유지해야 한다.
    - ref - https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf
- 데이터 방출(eviction) 정책
 - **Least Recently Used (LRU)** : 가장 오랫동안 사용되지 않은 데이터를 제거한다.
 - **Least Frequently Used (LFU)** : 가장 적게 사용된 데이터를 제거한다.
 - **First In First Out (FIFO)** : 가장 먼저 들어온 데이터를 제거한다.



### 6. CDN (콘텐츠 전송 네트워크)

- **CDN**은 정적 콘텐츠를 전송하는데 쓰이는 **분산 서버 네트워크**이다.
- 이미지, 비디오, CSS, JavaScript 등의 **정적 콘텐츠**를 **CDN**에 저장하여 **응답 시간을 단축**한다.
- **CDN** 어떻게 동작?
  - **Client**는 **가장 가까운 CDN 서버**에 요청을 보낸다.
  - **CDN 서버**는 **요청된 콘텐츠**를 **캐시**에 저장하고 **Client**에게 응답한다.
  - **CDN 서버**의 캐시에 해당 이미지가 없는 경우 **원본 서버**에 요청을 보내고 **캐시**에 저장한 후 **Client**에게 응답한다.
    - 원본 파일을 반환할 때 얼마나 오래 캐시될 수 있는지 설명하는 **TTL(Time To Live)** 값이 들어 있다.



### 7. Message Queue (메시지 큐)

- **메시지 큐**는 **비동기 통신**을 위해 사용되는 **소프트웨어**이다.
- 메세지의 무손실을 보장하고, **시스템 간의 결합도를 낮추어** 시스템의 **확장성**을 높인다.
- 시간이 오래 걸릴수 있는 작업을 **비동기적으로 처리**할 수 있다.



### 8. Log, Metrics and Automation (로그, 메트릭, 자동화)

- **로그(Log)** : 시스템의 **상태**와 **동작**을 기록하는 것이다.
  - **로그**를 서버 단위로 모니터링 할 수도 있지만, 단일 서비스로 모아주는 **로그 집계 서비스**를 사용하는 것이 좋다.
- **메트릭(Metrics)** : 시스템의 **성능**을 측정하는 것이다.
  - 호스트 단위 메트릭 - CPU, 메모리, 디스크 사용량 등
  - 종합 메트릭 - 데이터베이스 계층의 성능, 캐시 계층의 성능 등
  - 핵심 비즈니스 메트릭 - 사용자의 활동, 매출, 재방문 등



### 9. Sharding (샤딩)

- **샤딩**은 **대용량 데이터베이스**를 **분할**하여 **여러 서버**에 분산 저장하는 방법이다.
- 모든 샤드는 같은 스키마를 가지고 있지만, **다른 데이터**를 저장한다.(중복이 없다.)
- 샤딩 키(sharding key)를 사용하여 **어떤 샤드에 데이터를 저장할지 결정**한다.
- 샤딩을 도입하면 시스템이 복잡해지는 단점이 있다.
  - 데이터의 재 샤딩(Re-sharding) : 샤딩 키를 변경하거나 샤드의 수를 변경하는 작업
    - 안정해시(consistent hashing) 기법으로 해결할 수 있다.
  - 유명인사(celebrity) 문제 : 핫스팟 키(hotspot key) 문제라고도 부르는데, 특정 샤드에만 데이터가 몰리는 현상 
    - 유명인사 각각에 샤드 하나씩을 할당하거나 더 잘게 쪼개는 방법으로 해결할 수 있다.
  - 조인과 비정규화 : 샤딩을 도입하면 조인이 어려워진다. 이를 해결하기 위해 비정규화(중복 허용)를 사용할 수 있다.
